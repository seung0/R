2020-06-14

R 2강

#벡터의 생성(숫자형, 문자형, 논리형, 범주형)
-숫자형 벡터
a <- c(1, 2) 
class(a)      ---> numeric
sum(a)        ---> 3

b <- c(1L, 2L)
class(b)      ----> integer
sum(b)        ----> 3

*numeric과 integer 모두 sum함수 사용이 가능


-문자형 벡터
c <-  c('hello', 'world')
print(c)                  ----> "hello" "world"
class(c)                  ----> character 
sum(c)                    ----> error

*문자형 벡터에 sum은 사용 불가

-논리형 벡터
d <- c(FALSE, TRUE)
print(d)          ----> FALSE TRUE
class(d)          ----> logical
as.integer(d)     ----> 논리형 벡터인 d를 정수형 벡터로 보여라(할당된 것은 아니라 class는 여전히 논리형 벡터로 나타남)
sum(d)            ----> 1 (TRUE의 갯수가 나옴)

-범주형 벡터
e <- as.factor(c)
print(e)         ----> hello world
class(e)         ----> factor
as.integer(e)    ----> 1 2
sum(e)           ----> error (범주형 벡터는 먼저 숫자형 벡터로 변환해야 합계를 계산할 수 있다.)

sum(as.integer(e)) ----> 3 

**숫자형, 논리형 벡터만 sum함수 사용 가능 (이외의 벡터들은 변환해줘야 가능)



#다양한 벡터 생성하기

-1부터 100까지 정수 중에서 짝수만 원소로 갖는 벡터
seq(2, 100, 2)

-R내장 문자 벡터인 'letters'의 홀수번째 알파벳만 원소로 갖는 벡터
letters[seq(1, 26, 2)]

-'letters'원소 중 3의 배수에 위치한 원소만 대문자로 변경
loc <- seq(3, 26, 3)
letters[loc] <- LETTERS[loc]
print(letters)

-총 360페이지짜리 책 한 권을 사서 R을 독학하려고 한다. 서문과 부록을 제외한 본문 16~351페이지를 28일 동안 같은 분량으로 나눠 공부할 예정이라면,
하루에 공부해야할 페이지를 백터로 생성
seq(15, 351, length = 29)

-총 길이 2018km에 해당하는 성화 봉송로를 7500명의 주자가 공평하게 나눠서 달린다고 가정할 때, 한 명의 주자가 달려야 할 구간을 벡터로 생성
seq(0, 2018, length = 7501)


#범주형 벡터 관련 함수
-혈액형, 학교명, 국가명처럼 일부 문자열이 반복되는 경우 문자형 벡터로 저장하는 것보다 범주형 벡터로 변환하는 것이 좋습니다.

우선, vec이라는 벡터를 생성하면,
vec <- c('한국', '일본', '중국', '미국', '중국', '한국', '미국', '한국', '일본')

class(vec) ----> character

이 문자형 벡터를 범주형 벡터로 변환해주려면,
fct1 <- factor(vec)

이런 식으로 할당식을 세워주어야 한다. as.factor로 변환을 하면 levels, labels를 직접 설정할 수 없음
print(fct1)을 실행하면 범주형 벡터로 변환된 것을 확인할 수 있음

이 범주형 벡터의 levels 순서를 바꾸고 싶을 때, 
fct2 <- factor(vec, levels = c('한국', '미국', '중국', '일본'))
print(fct2)를 실행하면 명령한 levels순서로 바뀐 것을 확인할 수 있다.
*labes 순서 바꿀 때도 같은 방법으로


-문자형 벡터와 범주형 벡터의 원소를 변경할 때

문자형 벡터의 9번째 원소를 '대만'으로 바꾸면
vec[9] <- '대만'
print(vec)
9번째 원소가 '대만'으로 변경

범주형 벡터의 9번째 원소를 '대만'으로 바꾸면
fct1[9] <- '대만' ----> error
print(fct1)      ----> 9번째 원소가 NA로 표기됨

범주형 벡터의 원소를 바꿀 때는 
1)levels에 새로운 원소를 추가해주거나
2)문자형 벡터로 변환해서 원소를 변경한 후 다시 범주형 벡터로 변환하는 방법

levels(fct1) <- c('한국', '미국', '중국', '일본', '대만')
fct1[9] <- '대만'
print(fct1)

fct1의 9번째 원소가 '대만'으로 변경되어 있는 것을 확인할 수 있다.
또는

fct1[9] <- '홍콩' ----> error

문자형 벡터로 변환해주고
q <- as.character(fct1)

9번째 원소를 지정해주면
q[9] <- '홍콩'
print(q)를 실행하면 9번째 원소가 '홍콩'으로 바뀌어 있는 것을 확인할 수 있다.

그 후에 다시 범주형 벡터로 변환해준다.
fct1 <- factor(q)
fct1


-범주형 벡터를 생성할 때 레벨의 라벨(label)을 별도로 지정할 수 있다.

1) 
fct3 <- factor(vec, levels = c('한국', '미국', '중국', '일본', '대만'), 
                    labels = c('대한민국', '미합중국', '중화인민공화국', '일본국', '대만'))
print(fct3)

2)
levels(fct2) <- c('대한민국', '미합중국', '중화인민공화국', '일본국')
print(fct2)

*level의 수가 같을 때만 실행된다. level의 수가 다르다면 위의 factor 함수를 실행해야 한다. 


#벡터의 강제 변환(coercion)

-두 종류의 다른 벡터끼리 결합했을 때 하위 레벨의 벡터가 상위 레벨의 벡터로 변환되는 것

논리형 벡터인 d와 범주형 벡터인 e를 결합했을 때,
f <- c(d, e)
class(f)    ----> integer

정수형 벡터로 강제 변환된 f와 실수형 벡터를 결합했을 때,
f <- c(f, 3)
class(f)    ----> numeric

실수형 벡터로 강제 변환된 f와 문자형 벡터를 결합했을 때,
f <- c(f, '4')
class(f).   ----> character


**문자형 벡터 >> 실수형 벡터 >> 정수형 벡터 >> 논리형 벡터, 범주형 벡터


**문자형 벡터를 숫자 벡터로 변환
as.integer(f)
as.numeric(f)


#벡터의 인덱싱
-벡터 인덱싱(indexing)은 벡터의 원소에 '위치 번호(인덱스)'를 붙이는 것
-홑대괄호 안에 인덱스를 지정하면 해당 원소를 반환한다. 
-홑대괄호 안에 인덱스 대신 벡터의 원소 길이만큼 TRUE 또는 FALSE를 지정하면, TRUE에 해당하는 위치의 원소를 반환한다.

a <- c('a', 'b', 'c', 'd', 'e')
a라는 벡터를 정의하고, 이 벡터의 첫 번째, 세 번째, 다섯 번째 원소를 불러들일 때,

1)Fancy Indexing
a[c(1, 3, 5)]

2)Boolean Indexing
a[c(T, F, T, F, T)]

**보통 Boolean Indexing을 많이 사용한다.


#벡터의 슬라이싱
-벡터의 슬라이싱은 콜론(:)을 사용하여 벡터의 일부를 선택하는 것
a <- letters[1:5]
print(a)

b <- LETTERS[6:10]
print(b)


#벡터 원소의 삭제 및 변환
-인덱스 앞에 '-'부호를 추가하면 해당 원소를 삭제한다.

a[-1]       ----> b, c, d, e
a[-c(1, 3)] ----> b, d, e
print(a)    ----> a, b, c, d, e

*삭제한 결과를 출력할 뿐 원래 a는 모든 원소를 가지고 있다.
 print했을 때의 삭제된 결과를 얻으려면 다른 객체로 할당해야 한다.

b <- a[-c(1, 3)]
print(b)    ----> b, d, e


-특정 위치의 원소를 다른 값으로 대체
a[1] <- 'A'
print(a) ----> A b c d e



#수학 연산자
-벡터 a와 b의 길이가 같을 때, 대응하는 원소끼리 수학 연산을 실행한다.
-만약 두 벡터의 길이가 다른 경우라면, 길이가 짧은 벡터의 원소를 반복하여 길이가 긴 벡터와 길이를 맞춘다.

a + b
a - b
a * b
a / b
a %% b  : 앞 벡터의 원소를 뒷 벡터의 원소로 나눈 나머지
a %/% b : 앞 벡터의 원소를 뒷 벡터의 원소로 나눈 몫
a ^ b


#비교 연산자
-벡터 a와 b의 길이가 같을 때, 대응하는 원소끼리 비교한 결과

a > b
a >= b
a < b
a <= b
a == b
a != b

*TRUE/FALSE로 반환


#논리 연산자
-R에서 벡터의 원소에 대해 참(TRUE)과 거짓(FALSE)를 판별하는 기준은 원소가 0인지 여부에 따라 결정된다.
 즉 0이면 FALSE이고, 0이 아니면 TRUE이다.
-논리 연산자는 벡터의 원소가 참(TRUE)과 거짓(FALSE)을 판별할 때 사용된다.

& : 두 벡터의 원소가 모두 값을 가지면 TRUE, 어느 하나라도 0이면 FALSE
| : 두 벡터의 원소 중 어느 하나라도 값을 가지면 TRUE, 둘 다 0이면 FALSE
! : 벡터의 원소가 값을 가지면 FALSE, 0이면 TRUE (반대)
&& : 두 벡터의 첫 번째 원소가 모두 값을 가지면 TRUE, 어느 하나라도 0이면 FALSE
|| : 두 베거의 첫 번째 원소 중 어느 하나라도 값을 가지면 TRUE, 둘 다 0이면 FALSE



 










































